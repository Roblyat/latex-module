\chapter{Implementation}
    \label{subsec:practical}
    This approach, which isolates the external forces resulting from the gripper's rigid body \(\phi_{\text{gripper}}\) through estimation, is implemented using a Robot Operating System (ROS)-based simulation \cite{ros_official}, with Gazebo \cite{gazebo_ros} as the physics simulator and ROS MoveIt \cite{moveit} as the motion planning interface for the UR5 robotic arm \cite{ur5_robot}. The simulation setup leverages a \texttt{<xacro>} \cite{xacro_docs} configuration to model the robot and its control interfaces and the gazebo simulation environment. The ROS Control framework \cite{ros_control} is employed, integrating an effort transmission interface and an effort-based controller for controlling the UR5 robot in Gazebo. Additionally, a joint state interface is utilized to retrieve sensor feedback, including joint positions, velocities, and efforts. The system employs a joint\_trajectory interface, enabling the effort joint\_trajectory controller to provide comprehensive sensor data for the robotâ€™s motors encompassing position, velocity, and effort.
    The motor sensor data is achieved from the \texttt{joint\_states} ROS topic \cite{rospy}.
    The \texttt{<libgazebo\_ros\_ft\_sensor.so>} plugin is used to generate the f/t-measurement with its measurement frame located between the force/torque-sensor flange and the gripper mounting plate. The f/t-measurement sensor data is achieved from the \texttt{/wrench} ROS topic \cite{rospy}. The recorded sensor data is saved as \(\mathcal{D}_{\text{sensors}}\)~\eqref{eq:dataset_raw} and preprocessed for the \(\boldsymbol{GP}_{\text{model}}\) training following ~(Sec. \ref{subsec:preprocess}). For handling file paths during this pipeline the Core Python \texttt{os} \cite{python_os} library is used. The data preprocessing is done in Python 3 with the \texttt{pandas} \cite{pandas} library for data manipulation and analysis, the \texttt{numpy} \cite{numpy} library for numerical operations and array handling, and the \texttt{sklearn.preprocessing} \cite{scikit_learn} library for scaling data. The \(\boldsymbol{GP}_{\text{model}}\) training, following~(Sec. \ref{subsec:gaussian}), is done with the \texttt{GPy} \cite{gpy} library for Gaussian Process modeling, the \texttt{sklearn.model\_selection} library for data splitting and cross-validation, and the \texttt{sklearn.metrics} library for evaluating model performance. The \texttt{numpy} library is also used for \(\boldsymbol{GP}_{\text{model}}\) saving. For plotting graphs and visualizing results the \texttt{matplotlib.pyplot} \cite{matplotlib} library is used.
    Two Datasets \(\mathcal{D}\)~\eqref{eq:dataset_raw} are recorded. Both contain Cartesian trajectories, whereby the sensor data of the robot is recorded during the execution of the trajectories. The data sets differ in the orientation of the TCP between the start and destination points of the recorded trajectories. For both data sets, the next target position is sampled random from a cube whose center is located on the TCP. The edge lengths of this cube are 1 meter. The maximum velocity and acceleration for the trajectories are sampled randomly from the value ranges \( r_{\text{velocity}} = [0.01, 0.3] \) and \( r_{\text{acceleration}} = [0.01, 0.5] \). The dataset \(\mathcal{D}_{\text{Cartesian}}\) contains the sensor data of 1000 recorded Cartesian trajectories where the TCP and MF coordinate systems \texttt{xy}-planes are parallel to the environments \texttt{xy}-plane. The dataset \(\mathcal{D}_{\text{CartesianOC}}\) (Orientation Change, OC) contains the sensor data of 1000 trajectories where the TCP's orientation is changed from the start point to the destination point of the trajectory. The trajectories were chosen because executing Cartesian paths without orientation changes reduces multivalence in the data compared to paths with orientation changes. The shaft position of one motor at two different timestamps can be the same, while the shaft positions of the other five motors differ at these two timestamps. This is why the same motor position at two different timestamps can require a different effort the motor uses, with respect to the dynamic inertia matrix \(\boldsymbol{M}\)~\eqref{eq:robot_dynamics} of the robot. This approach enables the evaluation of how effectively a Gaussian process responds to multivariate distributions as an estimation method for payload assessment. For evaluation the trained \(\boldsymbol{GP}_{\text{models}}\) 100 Cartesian trajectories are executed while the \(\boldsymbol{GP}_{\text{models}}\) predict live. The models are live tested against the ground truth sensor measurements while executing trajectories computed in the same pattern then the trajectories the dataset contains with the models are trained with. All trajectories, both for training and during testing, are executed without payload. Therefore 

    \begin{equation}
    \phi_{\text{effective}} = \phi_{\text{payload}}
    \label{eq:isolateGripper}
    \end{equation}
    
    what means that the difference between the actual f/t measurements and the estimated measurements is zero. 

    For each dataset, 10 \(\boldsymbol{GP}_{\text{effort}}\) models and 10 \(\boldsymbol{GP}_{\text{wrench}}\) models are trained sequentially with incrementally larger random sub samples. Starting with an initial subset defined by the step size, each model trains on a progressively larger portion of data. The number of inducing points is set to 3\% of the sample size in each iteration, adapting dynamically to balance computational efficiency with model fidelity. All training loops are initialized with 70000 subsamples, this is why the first model is trained with 7000 subsamples and and the last model with 70000.

    All models are tested predicting live while the robot executes its computed random trajectories. The \(\boldsymbol{GP}_{\text{effort}}\) models are tested to evaluate the effort prediction against the motor effort ground truth, as well as the \(\boldsymbol{GP}_{\text{wrench}}\) models to evaluate against the f/t measurement ground truth for both Dataset types \(\mathcal{D}_{\text{Cartesian}}\) and \(\mathcal{D}_{\text{CartesianOC}}\). In order to evaluate how accurately the resulting forces of the gripper can be isolated, the models that performed best for the respective data set are tested in series. For each Dataset \(\mathcal{D}_{\text{Cartesian}}\) and \(\mathcal{D}_{\text{CartesianOC}}\) one estimation against the ground truth ~(Sec. \ref{subsec:preprocess}) 
    
    \begin{equation}
    \text{step size} = \frac{\text{total dataset size}}{10}
    \label{eq:step_size}
    \end{equation}