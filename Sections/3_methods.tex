\section{Methods}
\subsection{Stage~1: Structured inverse dynamics for robot + fixed gripper}

In a first step, we learn a nominal inverse-dynamics model for the
robot--gripper system without payload and without contact.
From the synchronised dataset we obtain
\[
\bigl\{
  \mathbf{q}_k,\dot{\mathbf{q}}_k,\ddot{\mathbf{q}}_k,
  \boldsymbol{I}_k,\vec{F}_{\mathrm{meas},k}
\bigr\}_{k=1}^{N},
\]
where $\mathbf{q}_k,\dot{\mathbf{q}}_k,\ddot{\mathbf{q}}_k \in \mathbb{R}^n$ are
joint position, velocity and acceleration, $\boldsymbol{I}_k \in \mathbb{R}^n$
are motor currents, and $\vec{F}_{\mathrm{meas},k} \in \mathbb{R}^6$ is the
measured flange wrench in the sensor frame $S$.
For brushless DC motors with torque constant $k_t$, the measured motor torques are
\begin{equation}
  \boldsymbol{\tau}_{\mathrm{motor},k} = k_t\,\boldsymbol{I}_k.
\end{equation}

The nominal robot--gripper dynamics are parameterised by a Deep Lagrangian
Network (DeLaN) with parameters $\boldsymbol{\theta}$ for the conservative
dynamics and $\boldsymbol{\psi}$ for friction and other non-conservative terms.
The network implements a Lagrangian
\begin{equation}
  \mathcal{L}_{\boldsymbol{\theta}}\bigl(\mathbf{q},\dot{\mathbf{q}}\bigr)
  =
  \tfrac{1}{2}\,\dot{\mathbf{q}}^{\top}
  \mathbf{M}_{\boldsymbol{\theta}}(\mathbf{q})\,\dot{\mathbf{q}}
  -
  V_{\boldsymbol{\theta}}(\mathbf{q}),
\end{equation}
with positive-definite inertia matrix $\mathbf{M}_{\boldsymbol{\theta}}(\mathbf{q})$
(e.g.\ represented via a Cholesky-factor network) and potential
$V_{\boldsymbol{\theta}}(\mathbf{q})$ represented by a neural network.
Using the Euler--Lagrange equations yields the conservative joint torques
\begin{equation}
  \boldsymbol{\tau}_{\mathrm{cons}}
  (\mathbf{q},\dot{\mathbf{q}},\ddot{\mathbf{q}};\boldsymbol{\theta})
  =
  \mathbf{M}_{\boldsymbol{\theta}}(\mathbf{q})\,\ddot{\mathbf{q}}
  +
  \mathbf{C}_{\boldsymbol{\theta}}(\mathbf{q},\dot{\mathbf{q}})\,\dot{\mathbf{q}}
  +
  \mathbf{G}_{\boldsymbol{\theta}}(\mathbf{q}),
\end{equation}
where $\mathbf{C}_{\boldsymbol{\theta}}$ and $\mathbf{G}_{\boldsymbol{\theta}}$ are
implicitly defined by $\mathcal{L}_{\boldsymbol{\theta}}$.
Joint friction and other non-conservative effects are modelled by an additional
term $\boldsymbol{\tau}_{\mathrm{fric}}(\dot{\mathbf{q}};\boldsymbol{\psi})$,
for example a parametric Coulomb/viscous/Stribeck model or a small neural
network.

The DeLaN torque prediction is the sum of conservative and frictional parts,
\begin{equation}
  \hat{\boldsymbol{\tau}}_{\mathrm{DeLaN}}
  (\mathbf{q},\dot{\mathbf{q}},\ddot{\mathbf{q}};\boldsymbol{\theta},\boldsymbol{\psi})
  =
  \boldsymbol{\tau}_{\mathrm{cons}}
    (\mathbf{q},\dot{\mathbf{q}},\ddot{\mathbf{q}};\boldsymbol{\theta})
  +
  \boldsymbol{\tau}_{\mathrm{fric}}(\dot{\mathbf{q}};\boldsymbol{\psi}).
\end{equation}
For sample $k$ this becomes
\begin{equation}
  \hat{\boldsymbol{\tau}}_{\mathrm{DeLaN},k}
  =
  \hat{\boldsymbol{\tau}}_{\mathrm{DeLaN}}
  (\mathbf{q}_k,\dot{\mathbf{q}}_k,\ddot{\mathbf{q}}_k;
   \boldsymbol{\theta},\boldsymbol{\psi}).
\end{equation}

The parameters $(\boldsymbol{\theta},\boldsymbol{\psi})$ are trained offline by
minimising a joint-space regression loss
\begin{equation}
  \mathcal{L}_{\mathrm{DeLaN}}(\boldsymbol{\theta},\boldsymbol{\psi})
  =
  \frac{1}{N}\sum_{k=1}^{N}
  \left\|
    \hat{\boldsymbol{\tau}}_{\mathrm{DeLaN}}
      (\mathbf{q}_k,\dot{\mathbf{q}}_k,\ddot{\mathbf{q}}_k;
       \boldsymbol{\theta},\boldsymbol{\psi})
    -
    \boldsymbol{\tau}_{\mathrm{motor},k}
  \right\|_2^2.
  \label{eq:delan_joint_loss}
\end{equation}
Note that this training objective uses only joint states and motor torques; the
force/torque sensor is not required for fitting the DeLaN model.

After training, the DeLaN parameters are frozen and the model serves as a
data-driven nominal inverse-dynamics model of the robot--gripper system.
For later use in the measurement frame, the corresponding nominal flange
wrench is obtained by mapping joint torques through the Jacobian of the
sensor frame $S$,
\begin{equation}
  \hat{\vec{F}}_{\mathrm{DeLaN},k}
  =
  {}^{S}\!J(\mathbf{q}_k)^{-\top}\,
  \hat{\boldsymbol{\tau}}_{\mathrm{DeLaN}},
  \label{eq:delan_wrench}
\end{equation}
assuming a square, invertible Jacobian for the considered configuration
(or using the least-squares solution if redundant).

\subsection{Stage~2: Sequence model for residual flange wrench}

In the second stage, we model history-dependent effects that are not captured
by the structured DeLaN model, such as backlash and fine-grained nonlinear
friction. Using the same robot--gripper dataset (still without payload and
without contact), we first compute the nominal flange wrench for each sample
via~\eqref{eq:delan_wrench} and define the residual wrench
\begin{equation}
  \vec{r}_{F,k}
  =
  \vec{F}_{\mathrm{meas},k}
  -
  \hat{\vec{F}}_{\mathrm{DeLaN},k}.
  \label{eq:wrench_residual}
\end{equation}

Let $H$ denote the sequence length (number of time steps in the history
window). For each time index $k \geq H$ we construct an input sequence
\begin{equation}
  \mathbf{x}_k
  =
  \Bigl[
    \mathbf{q}_{k-H+1:k},\,
    \dot{\mathbf{q}}_{k-H+1:k},\,
    \ddot{\mathbf{q}}_{k-H+1:k},\,
    \hat{\boldsymbol{\tau}}_{\mathrm{DeLaN},k-H+1:k}
  \Bigr],
\end{equation}
where $\mathbf{q}_{a:b}$ denotes the stacked joint vectors
$(\mathbf{q}_a,\dots,\mathbf{q}_b)$, and analogously for
$\dot{\mathbf{q}}$, $\ddot{\mathbf{q}}$ and
$\hat{\boldsymbol{\tau}}_{\mathrm{DeLaN}}$.

An LSTM with parameters $\boldsymbol{\varphi}$ maps this sequence to a
residual-wrench prediction
\begin{equation}
  \hat{\vec{r}}_{F,k}
  =
  f_{\mathrm{LSTM}}(\mathbf{x}_k;\boldsymbol{\varphi})
  \in \mathbb{R}^6.
\end{equation}
The LSTM is trained to minimise the mean-squared error between predicted and
true residual wrenches,
\begin{equation}
  \mathcal{L}_{\mathrm{LSTM}}(\boldsymbol{\varphi})
  =
  \frac{1}{N_H}
  \sum_{k=H}^{N}
  \left\|
    \hat{\vec{r}}_{F,k}
    -
    \vec{r}_{F,k}
  \right\|_2^2,
  \label{eq:lstm_loss}
\end{equation}
where $N_H = N-H+1$ is the number of valid sequences.

The combined flange-wrench model for the robot--gripper system is then
\begin{equation}
  \hat{\vec{F}}_{\mathrm{RG},k}
  =
  \hat{\vec{F}}_{\mathrm{DeLaN},k}
  +
  \hat{\vec{r}}_{F,k}.
  \label{eq:combined_wrench_rg}
\end{equation}
Since both stages are trained exclusively on data without payload and without
environment contact, $\hat{\vec{F}}_{\mathrm{RG},k}$ represents a
high-fidelity, history-aware model of the nominal robot--gripper wrench.
In later stages, deviations between this model and the measured wrench can be
attributed to the effective rigid-body contribution of additional payloads.
